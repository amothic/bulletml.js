<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>Source - src\main\bulletml.enchant.js</title>
	<meta name="generator" content="JsDoc Toolkit" />

	<link media="all" rel="stylesheet" href="../../css/common.css" type="text/css" />
	<link media="all" rel="stylesheet" href="../../css/bootstrap.min.css" type="text/css" />
	<link media="all" rel="stylesheet" href="../../css/prettify.css" type="text/css" />
	<link media="print" rel="stylesheet" href="../../css/print.css" type="text/css" />
	<style type="text/css">
		.icon-jsdoc {
			background: url("../../img/classicons.png") no-repeat;
		}
	</style>
	<script type="text/javascript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
	<script src="../../js/prettify.js" type="text/javascript"></script>
	<script src="../../js/bootstrap.min.js" type="text/javascript"></script>
</head>
<body><div class="container-fluid">
<!-- ============================== header ================================= -->
	<!-- begin static/header.html -->
	<header class="header navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container-fluid">
				<a class="brand" href="#"><strong>JsDoc</strong> Reference</a>
				<ul id="class-file-selector" class="nav">
					<li><a href="../../index.html">Class Index</a></li>
					<li><a href="../../files.html">File Index</a></li>
				</ul>
			</div>
		</div>
	</header>
	<!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
	<div class="row-fluid">
		<div id="index" class="span3">
			<!-- begin publish.classesIndex -->
			<div class="well" id="class-list">
	<ul class="nav nav-list">
		<li class="nav-header">Classes</li>
		
			<li><a href="../../symbols/BulletML.html"><span class="indent" style="padding-left:0px;"><i class="icon-jsdoc icon-jsdoc-namespace"></i><span class="jsdoc-class-index">BulletML</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Accel.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Accel</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Action.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Action</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.ActionRef.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">ActionRef</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Bullet.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Bullet</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.BulletRef.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">BulletRef</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.ChangeDirection.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">ChangeDirection</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.ChangeSpeed.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">ChangeSpeed</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Command.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Command</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Direction.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Direction</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Fire.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Fire</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.FireRef.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">FireRef</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Horizontal.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Horizontal</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Repeat.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Repeat</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Root.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Root</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Speed.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Speed</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Vanish.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Vanish</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Vertical.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Vertical</span></span></a></li>
		
			<li><a href="../../symbols/BulletML.Wait.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">Wait</span></span></a></li>
		
			<li><a href="../../symbols/_global_.html"><span class="indent" style="padding-left:0px;"><i class="icon-jsdoc icon-jsdoc-namespace"></i><span class="jsdoc-class-index">_global_</span></span></a></li>
		
			<li><a href="../../symbols/enchant.bulletml.html"><span class="indent" style="padding-left:14px;"><i class="icon-jsdoc icon-jsdoc-namespace"></i><span class="jsdoc-class-index">bulletml</span></span></a></li>
		
			<li><a href="../../symbols/enchant.bulletml.AttackPattern.html"><span class="indent" style="padding-left:28px;"><i class="icon-jsdoc icon-jsdoc-class"></i><span class="jsdoc-class-index">AttackPattern</span></span></a></li>
		
	</ul>
</div>

			<!-- end publish.classesIndex -->
		</div>

		<div id="content" class="span9">
<!-- ============================== source code ============================ -->

			<pre id="source-code" class="prettyprint linenums">/**
 * @fileOverview bullet.enchant.js
 * @version 0.4.1
 * @require enchant.js v0.5.2+, bulletml-min.js v0.3.1
 * @author daishi_hmr
 *
 * @description 弾幕記述言語BulletMLをenchant.jsで扱うためのプラグイン
 *
 * @detail BulletMLのパースにはbulletml.jsを使用しています
 *      bulletml.js: https://github.com/daishihmr/bulletml.js
 *
 * @example
 *      game.preload('boss.bml');
 *      ...
 *      var player = new Sprite(32, 32);
 *      var boss = new Sprite(32, 32);
 *      var attackPattern = game.assets['boss.xml'];
 *      var ticker = attackPattern.createTicker(player);
 *      boss.addEventListener('enterframe', ticker);
 *
 * @example
 *      game.preload('boss.bml');
 *      ...
 *      var player = new Sprite(32, 32);
 *      AttackPattern.defaultConfig.target = player;
 *      var boss = new Sprite(32, 32);
 *      boss.setDanmaku(game.assets['boss.bml']);
 */

/**
 * @namespace
 */
enchant.bulletml = enchant.bulletml || {};

(function() {

    // BulletML(*.bml, *.xml)をpreloadで読み込めるようにする.
    enchant.Game._loadFuncs["bml"] = enchant.Game._loadFuncs["xml"] = function(
            src, callback) {
        var game = this;
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function(e) {
            if (xhr.readyState === 4) {
                if (xhr.status !== 200 &amp;&amp; xhr.status !== 0) {
                    throw new Error(xhr.status + ': '
                            + 'Cannot load an asset: ' + src);
                }

                if (xhr.responseXML != null) {
                    var bulletml = BulletML.build(xhr.responseXML);
                    if (bulletml) {
                        game.assets[src] = new enchant.bulletml.AttackPattern(
                                bulletml);
                    } else {
                        alert(src + "は妥当なBulletMLではありません。");
                        game.assets[src] = xhr.responseXML;
                    }
                    callback();
                } else {
                    throw new Error(xhr.status + ': '
                            + 'Cannot load an asset: ' + src);
                }
            }
        };

        xhr.open('GET', src, true);
        if (xhr.overrideMimeType) {
            xhr.overrideMimeType("application/xml");
        }
        xhr.send(null);
    };

    // syntax sugar.
    /**
     * 弾幕enterframeイベントリスナを設定する.
     *
     * @scope enchant.EventTarget.prototype
     */
    enchant.EventTarget.prototype.setDanmaku = function(attackPattern, config) {
        if (attackPattern === void 0) throw new Error("AttackPattern is required.");
        this.removeDanmaku();
        this.on("enterframe", attackPattern.createTicker(config));
    };
    enchant.EventTarget.prototype.removeDanmaku = function() {
        if (!this._listeners["enterframe"]
                || this._listeners["enterframe"].length === 0) {
            return;
        }
        var remove = [];
        for ( var i = this._listeners["enterframe"].length; i--;) {
            if (this._listeners["enterframe"][i].isDanmaku) {
                remove[remove.length] = this._listeners["enterframe"][i];
            }
        }
        for ( var i = remove.length; i--;) {
            this.removeEventListener("enterframe", remove[i]);
        }
    };

    /**
     * 弾の画像が指定されなかった場合に使用される.
     *
     * 8px x 8px.赤い球状の弾.
     *
     * @type {enchant.Surface}
     * @memberOf enchant.bulletml
     */
    enchant.bulletml.getDefaultImage = function() {
        if (this.value) {
            return this.value;
        } else {
            var s = new enchant.Surface(8, 8);
            var c = s.context;
            var g = c.createRadialGradient(4, 4, 0, 4, 4, 4);
            g.addColorStop(0.0, "rgba(255,255,255,1.0)");
            g.addColorStop(0.5, "rgba(255,255,255,1.0)");
            g.addColorStop(0.8, "rgba(255,  0,  0,0.8)");
            g.addColorStop(1.0, "rgba(255,  0,  0,0.0)");
            c.fillStyle = g;
            c.fillRect(0, 0, 8, 8);
            this.value = s;
            return s;
        }
    };

    /**
     * bulletFactory未指定時に使用される弾スプライトの生成関数.
     *
     * @returns {enchant.Sprite} 8px x 8px の大きさのスプライト
     * @type function
     * @memberOf enchant.bulletml
     */
    enchant.bulletml.defaultBulletFactory = function() {
        var bullet = new enchant.Sprite(8, 8);
        bullet.image = enchant.bulletml.getDefaultImage();
        return bullet;
    };

    var _game = undefined;
    /**
     * isInsideOfWorld未指定時に使用される関数.
     */
    enchant.bulletml.defaultIsInsideOfWorld = function(bullet) {
        if (_game === void 0) {
            _game = enchant.Game.instance;
        }
        var scw = _game.width;
        var sch = _game.height;
        var w = bullet.width || 0;
        var h = bullet.height || 0;
        return (-w &lt;= bullet.x &amp;&amp; bullet.x &lt; scw &amp;&amp; -h &lt;= bullet.y &amp;&amp; bullet.y &lt; sch);
    };

    /**
     * @scope enchant.bulletml.AttackPattern.prototype
     */
    enchant.bulletml.AttackPattern = enchant.Class.create({
        /**
         * 攻撃パターン.
         *
         * @constructs
         * @param {BulletML.Root}
         *            bulletml BulletMLデータ
         */
        initialize : function(bulletml) {
            if (!bulletml) {
                throw new Error("argument is invalid.", bulletml);
            }
            this._bulletml = bulletml;
        },
        /**
         * enterframeイベントのリスナを作成する.&lt;br&gt;
         * &lt;br&gt;
         * 第1引数configで各種設定を行う. &lt;br&gt;
         *
         *
         * @param {Object|enchant.Node}
         *            [config] 発射される弾に関する設定.&lt;br&gt;
         *            &lt;table border=1&gt;
         *            &lt;tr&gt;
         *            &lt;th&gt;プロパティ名&lt;/th&gt;
         *            &lt;th&gt;型&lt;/th&gt;
         *            &lt;th&gt;設定内容&lt;/th&gt;
         *            &lt;th&gt;デフォルト値&lt;/th&gt;
         *            &lt;th&gt;必須&lt;/th&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;target&lt;/td&gt;
         *            &lt;td&gt;enchant.Node&lt;/td&gt;
         *            &lt;td&gt;攻撃の標的となるオブジェクト&lt;/td&gt;
         *            &lt;td&gt;null&lt;/td&gt;
         *            &lt;td&gt;○&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;addTarget&lt;/td&gt;
         *            &lt;td&gt;enchant.Group&lt;/td&gt;
         *            &lt;td&gt;生成した弾を追加するノード&lt;/td&gt;
         *            &lt;td&gt;攻撃を実行するノードのparentNode&lt;/td&gt;
         *            &lt;td&gt;&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;bulletFactory&lt;/td&gt;
         *            &lt;td&gt;function&lt;/td&gt;
         *            &lt;td&gt;弾ノードを生成する関数&lt;/td&gt;
         *            &lt;td&gt;小さな赤い弾を生成&lt;/td&gt;
         *            &lt;td&gt;&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;updateProperties&lt;/td&gt;
         *            &lt;td&gt;boolean&lt;/td&gt;
         *            &lt;td&gt;弾のプロパティ(direction, speed)を更新するかどうか&lt;/td&gt;
         *            &lt;td&gt;false&lt;/td&gt;
         *            &lt;td&gt;&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;isInsideOfWorld&lt;/td&gt;
         *            &lt;td&gt;function&lt;/td&gt;
         *            &lt;td&gt;弾が画面内に存在することを判定する関数&lt;/td&gt;
         *            &lt;td&gt;Gameインスタンスの大きさをベースにして判定する&lt;/td&gt;
         *            &lt;td&gt;&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;rank&lt;/td&gt;
         *            &lt;td&gt;number&lt;/td&gt;
         *            &lt;td&gt;弾幕ランク.BulletMLの$rankに対応する.0.0～1.0の範囲で指定.&lt;/td&gt;
         *            &lt;td&gt;0&lt;/td&gt;
         *            &lt;td&gt;&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;tr&gt;
         *            &lt;td&gt;speedRate&lt;/td&gt;
         *            &lt;td&gt;number&lt;/td&gt;
         *            &lt;td&gt;弾速度の補正倍率.&lt;/td&gt;
         *            &lt;td&gt;1&lt;/td&gt;
         *            &lt;td&gt;&lt;/td&gt;
         *            &lt;/tr&gt;
         *            &lt;/table&gt;
         *            設定する項目がtargetのみの場合、標的オブジェクトを直接引数として渡すことが可能.
         * @param {string}
         *            [action] 最初に読み込むactionのラベル.&lt;br&gt;
         *            省略可.
         */
        createTicker : function(config, action) {
            var topLabels = this._bulletml.getTopActionLabels()
            if (action === void 0 &amp;&amp; topLabels.length &gt; 1) {
                // top***対応.
                // actionラベルtop***が定義されていた場合、それらを同時に動かす.
                var tickers = [];
                for ( var i = 0, end = topLabels.length; i &lt; end; i++) {
                    tickers[tickers.length] = this._createTicker(config, topLabels[i]);
                }
                var parentTicker = function() {
                    if (parentTicker.complete) {
                        return;
                    }
                    for ( var i = tickers.length; i--;) {
                        tickers[i].call(this);
                    }
                    if (parentTicker.compChildCount == tickers.length) {
                        parentTicker.complete = true;
                        this.dispatchEvent(new Event("completeattack"));
                    }
                };
                for ( var i = tickers.length; i--;) {
                    tickers[i].parentTicker = parentTicker;
                }

                parentTicker.compChildCount = 0;
                parentTicker.completeChild = function() {
                    this.compChildCount++;
                };

                parentTicker.compChildCount = 0;
                parentTicker.complete = false;

                parentTicker.isDanmaku = true;

                return parentTicker;
            } else {
                return this._createTicker(config, action);
            }
        },
        _createTicker : function(config, action) {
            config = (function(base) {
                var result = {};
                var def = enchant.bulletml.AttackPattern.defaultConfig;
                for ( var prop in def) {
                    if (def.hasOwnProperty(prop)) {
                        if (base !== void 0) {
                            result[prop] = base[prop] || def[prop];
                        } else {
                            result[prop] = def[prop];
                        }
                    }
                }

                return result;
            })(config);
            if (!config.target) {
                throw new Error("target is undefined in config.");
            }

            // var ticker = tickerPool.get();
            var ticker = function() {
                var conf = ticker.config;
                var ptn = ticker._pattern;

                if (!ptn) {
                    return;
                }

                // update direction
                if (this.age &lt; ticker.chDirEnd) {
                    ticker.direction += ticker.dirIncr;
                } else if (this.age == ticker.chDirEnd) {
                    ticker.direction = ticker.dirFin;
                }

                // update speed
                if (this.age &lt; ticker.chSpdEnd) {
                    ticker.speed += ticker.spdIncr;
                } else if (this.age == ticker.chSpdEnd) {
                    ticker.speed = ticker.spdFin;
                }

                // update accel
                if (this.age &lt; ticker.aclEnd) {
                    ticker.speedH += ticker.aclIncrH;
                    ticker.speedV += ticker.aclIncrV;
                } else if (this.age == ticker.aclEnd) {
                    ticker.speedH = ticker.aclFinH;
                    ticker.speedV = ticker.aclFinV;
                }

                // move sprite
                this.x += Math.cos(ticker.direction) * ticker.speed * conf.speedRate;
                this.y += Math.sin(ticker.direction) * ticker.speed * conf.speedRate;
                this.x += ticker.speedH * conf.speedRate;
                this.y += ticker.speedV * conf.speedRate;

                // test out of world
                if (!conf.isInsideOfWorld(this)) {
                    this.parentNode.removeChild(this);
                    ticker.completed = true;
                    if (ticker.parentTicker) {
                        ticker.parentTicker.completeChild();
                    } else {
                        this.dispatchEvent(new Event("completeattack"));
                    }
                    return;
                }

                // set direction, speed to bullet
                if (conf.updateProperties) {
                    this.direction = (ticker.direction + Math.PI / 2) * RAD_TO_DEG;
                    this.speed = ticker.speed;
                }

                // proccess walker
                if (this.age &lt; ticker.waitTo || ticker.completed) {
                    return;
                }
                var cmd;
                while (cmd = ticker.walker.next()) {
                    switch (cmd.commandName) {
                    case "fire":
                        ptn._fire.call(this, cmd, conf,
                                ticker, ptn);
                        break;
                    case "wait":
                        var v = 0;
                        if (typeof(cmd.value) === 'number') {
                            ticker.waitTo = this.age + cmd.value;
                        } else if ((v = ~~(cmd.value)) !== 0) {
                            ticker.waitTo = this.age + v;
                        } else {
                            ticker.waitTo = this.age + eval(cmd.value);
                        }
                        return;
                    case "changeDirection":
                        ptn._changeDirection.call(this,
                                cmd, conf, ticker);
                        break;
                    case "changeSpeed":
                        ptn._changeSpeed.call(this, cmd,
                                ticker);
                        break;
                    case "accel":
                        ptn._accel.call(this, cmd, ticker);
                        break;
                    case "vanish":
                        if (this.parentNode) {
                            this.parentNode.removeChild(this);
                            // tickerPool.dispose(ticker);
                        }
                        break;
                    }
                }

                // complete
                ticker.completed = true;
                if (ticker.parentTicker) {
                    ticker.parentTicker.completeChild();
                } else {
                    this.dispatchEvent(new Event("completeattack"));
                }
            };

            if (action === void 0) {
                ticker.walker = this._bulletml.getWalker("top",
                        config.rank);
            } else if (typeof (action) === "string") {
                ticker.walker = this._bulletml.getWalker(action,
                        config.rank);
            } else if (action instanceof BulletML.Bullet) {
                ticker.walker = action.getWalker(config.rank);
            } else {
                console.error(config, action);
                throw new Error("引数が不正");
            }

            ticker._pattern = this;
            ticker.config = config;
            ticker.waitTo = -1;
            ticker.completed = false;
            ticker.direction = 0;
            ticker.lastDirection = 0;
            ticker.speed = 0;
            ticker.lastSpeed = 0;
            ticker.speedH = 0;
            ticker.speedV = 0;
            ticker.dirIncr = 0;
            ticker.dirFin = 0;
            ticker.chDirEnd = -1;
            ticker.spdIncr = 0;
            ticker.spdFin = 0;
            ticker.chSpdEnd = -1;
            ticker.aclIncrH = 0;
            ticker.aclFinH = 0;
            ticker.aclIncrV = 0;
            ticker.aclFinV = 0;
            ticker.aclEnd = -1;

            ticker.isDanmaku = true;
            return ticker;
        },
        _fire : function(cmd, config, ticker, pattern) {
            var b = config.bulletFactory({
                label : cmd.bullet.label
            });
            if (!b) {
                return;
            }

            var bt = pattern.createTicker(config, cmd.bullet);

            var attacker = this;
            var calcDirection = function(d) {
                var dv = eval(d.value) * DEG_TO_RAD;
                // console.debug(d.type);
                switch (d.type) {
                case "aim":
                    if (config.target) {
                        return angleAtoB(attacker, config.target) + dv;
                    } else {
                        return dv - Math.PI / 2;
                    }
                case "absolute":
                    return dv - Math.PI / 2; // 真上が0度
                case "relative":
                    return ticker.direction + dv;
                case "sequence":
                default:
                    // console.debug(ticker.lastDirection, dv);
                    return ticker.lastDirection + dv;
                }
            };
            ticker.lastDirection = bt.direction = calcDirection(cmd.direction || cmd.bullet.direction);
            // console.debug(bt.direction);

            var calcSpeed = function(s) {
                var sv = eval(s.value);
                switch (s.type) {
                case "relative":
                case "sequence":
                    return ticker.lastSpeed + sv;
                case "absolute":
                default:
                    return sv;
                }
            };
            ticker.lastSpeed = bt.speed = calcSpeed(cmd.speed || cmd.bullet.speed);

            b.x = this.x + ((this.width || 0) - (b.width || 0)) / 2;
            b.y = this.y + ((this.height || 0) - (b.height || 0)) / 2;

            b.addEventListener("enterframe", bt);
            b.addEventListener("removed", function() {
                this.removeEventListener("enterframe", bt);
            });
            if (config.addTarget) {
                config.addTarget.addChild(b);
            } else if (this.parentNode) {
                this.parentNode.addChild(b);
            }
        },
        _changeDirection : function(cmd, config, ticker) {
            var d = eval(cmd.direction.value) * DEG_TO_RAD;
            var t = eval(cmd.term);
            switch (cmd.direction.type) {
            case "aim":
                var tar = config.target;
                if (!tar) {
                    return;
                }
                ticker.dirFin = angleAtoB(this, tar) + d;
                ticker.dirIncr = normalizeRadian(ticker.dirFin - ticker.direction) / t;
                break;
            case "absolute":
                ticker.dirFin = d - Math.PI / 2;
                ticker.dirIncr = normalizeRadian(ticker.dirFin - ticker.direction) / t;
                break;
            case "relative":
                ticker.dirFin = ticker.direction + d;
                ticker.dirIncr = normalizeRadian(ticker.dirFin - ticker.direction) / t;
                break;
            case "sequence":
                ticker.dirIncr = d;
                ticker.dirFin = ticker.direction + ticker.dirIncr * t;
                break;
            }
            ticker.chDirEnd = this.age + t;
        },
        _changeSpeed : function(cmd, ticker) {
            var s = eval(cmd.speed.value);
            var t = eval(cmd.term);
            switch (cmd.speed.type) {
            case "absolute":
                ticker.spdFin = s;
                ticker.spdIncr = (ticker.spdFin - ticker.speed) / t;
                break;
            case "relative":
                ticker.spdFin = s + ticker.speed;
                ticker.spdIncr = (ticker.spdFin - ticker.speed) / t;
                break;
            case "sequence":
                ticker.spdIncr = s;
                ticker.spdFin = ticker.speed + ticker.spdIncr * t;
                break;
            }
            ticker.chSpdEnd = this.age + t;
        },
        _accel : function(cmd, ticker) {
            var t = eval(cmd.term);
            ticker.aclEnd = this.age + t;

            if (cmd.horizontal) {
                var h = eval(cmd.horizontal.value);
                switch (cmd.horizontal.type) {
                case "absolute":
                case "sequence":
                    ticker.aclIncrH = (h - ticker.speedH) / t;
                    ticker.aclFinH = h;
                    break;
                case "relative":
                    ticker.aclIncrH = h;
                    ticker.aclFinH = (h - ticker.speedH) * t;
                    break;
                }
            } else {
                ticker.aclIncrH = 0;
                ticker.aclFinH = ticker.speedH;
            }

            if (cmd.vertical) {
                var v = eval(cmd.vertical.value);
                switch (cmd.vertical.type) {
                case "absolute":
                case "sequence":
                    ticker.aclIncrV = (v - ticker.speedV) / t;
                    ticker.aclFinV = v;
                    break;
                case "relative":
                    ticker.aclIncrV = v;
                    ticker.aclFinV = (v - ticker.speedV) * t;
                    break;
                }
            } else {
                ticker.aclIncrV = 0;
                ticker.aclFinV = ticker.speedV;
            }
        },
        /**
         * 攻撃パターンの元となるBulletML定義.
         *
         * 解析済みのBulletMLオブジェクト.&lt;br&gt;
         * 読み取り専用.
         *
         * @type BulletML.Root
         */
        bulletml : {
            get : function() {
                return this._bulletml;
            }
        }
    });

    /**
     * configのデフォルト値.
     *
     * @scope enchant.bulletml.AttackPattern
     */
    enchant.bulletml.AttackPattern.defaultConfig = {
        bulletFactory : enchant.bulletml.defaultBulletFactory,
        isInsideOfWorld : enchant.bulletml.defaultIsInsideOfWorld,
        rank : 0,
        updateProperties : false,
        speedRate : 2
    };

    var RAD_TO_DEG = 180 / Math.PI;
    var DEG_TO_RAD = Math.PI / 180;

    /**
     * ラジアンを -π&lt;= rad &lt; π の範囲に正規化する.
     */
    function normalizeRadian(radian) {
        while (radian &lt;= -Math.PI) {
            radian += Math.PI * 2;
        }
        while (Math.PI &lt; radian) {
            radian -= Math.PI * 2;
        }
        return radian;
    }
    /**
     * スプライトAから見たスプライトBの方向をラジアンで返す.
     *
     * @param {enchant.Node}
     *            a スプライトA
     * @param {enchant.Node}
     *            b スプライトB
     */
    function angleAtoB(a, b) {
        var ca = {
            x : a.x + (a.width || 0) / 2,
            y : a.y + (a.height || 0) / 2
        };
        var cb = {
            x : b.x + (b.width || 0) / 2,
            y : b.y + (b.height || 0) / 2
        };
        return Math.atan2(cb.y - ca.y, cb.x - ca.x);
    }

})();
</pre>
		</div>
	</div>

<!-- ============================== footer ================================= -->
	<footer class="footer">
		
		<p>Documentation generated by <a href="http://code.google.com/p/jsdoc-toolkit/" target="_blankt">JsDoc Toolkit</a> 2.4.0 on Thu Dec 27 2012 15:09:57 GMT+0900 (JST)</p>
	</footer>
</div>
<script type="text/javascript">
	prettyPrint();
	var i = 1;
	$('#source-code li').each(function() {
		$(this).attr({ id: 'line' + (i++) });
	});
</script>
</body>
</html>
